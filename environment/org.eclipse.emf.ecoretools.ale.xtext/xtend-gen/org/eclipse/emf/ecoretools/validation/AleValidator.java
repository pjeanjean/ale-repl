/**
 * generated by Xtext 2.10.0
 */
package org.eclipse.emf.ecoretools.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.common.collect.Sets;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import org.eclipse.acceleo.query.runtime.IQueryEnvironment;
import org.eclipse.acceleo.query.runtime.IValidationMessage;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IMarker;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.IWorkspaceRoot;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.IPath;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecoretools.ale.ALEInterpreter;
import org.eclipse.emf.ecoretools.ale.Unit;
import org.eclipse.emf.ecoretools.ale.core.parser.Dsl;
import org.eclipse.emf.ecoretools.ale.core.parser.DslBuilder;
import org.eclipse.emf.ecoretools.ale.core.parser.visitor.ParseResult;
import org.eclipse.emf.ecoretools.ale.core.validation.ALEValidator;
import org.eclipse.emf.ecoretools.ale.implementation.ModelUnit;
import org.eclipse.emf.ecoretools.validation.AbstractAleValidator;
import org.eclipse.emf.workspace.util.WorkspaceSynchronizer;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * Delegate validation to ALE validator
 */
@SuppressWarnings("all")
public class AleValidator extends AbstractAleValidator {
  public static String ALE_MARKER = "org.eclipse.emf.ecoretools.ale.xtext.AleMarker";
  
  @Check
  public void checkIsValid(final Unit root) {
    try {
      final IFile aleFile = WorkspaceSynchronizer.getFile(root.eResource());
      this.cleanUpMarkers(aleFile);
      final IPath dslPath = aleFile.getFullPath().removeFileExtension().addFileExtension("dsl");
      final IWorkspaceRoot ws = ResourcesPlugin.getWorkspace().getRoot();
      final IFile dslFile = ws.getFile(dslPath);
      InputStream _contents = dslFile.getContents();
      final Dsl dsl = new Dsl(_contents);
      AleValidator.resolveUris(dsl);
      final ALEInterpreter interpreter = new ALEInterpreter();
      String _name = dslFile.getProject().getName();
      interpreter.initScope(Sets.<String>newHashSet(), Sets.<String>newHashSet(new String[] { _name }));
      IQueryEnvironment _queryEnvironment = interpreter.getQueryEnvironment();
      final List<ParseResult<ModelUnit>> parsedSemantics = new DslBuilder(_queryEnvironment).parse(dsl);
      final Function1<ParseResult<ModelUnit>, ModelUnit> _function = (ParseResult<ModelUnit> it) -> {
        return it.getRoot();
      };
      final Function1<ModelUnit, EList<String>> _function_1 = (ModelUnit it) -> {
        return it.getServices();
      };
      final List<String> services = IterableExtensions.<String>toList(Iterables.<String>concat(IterableExtensions.<ModelUnit, EList<String>>map(IterableExtensions.<ModelUnit>filterNull(ListExtensions.<ParseResult<ModelUnit>, ModelUnit>map(parsedSemantics, _function)), _function_1)));
      interpreter.registerServices(services);
      IQueryEnvironment _queryEnvironment_1 = interpreter.getQueryEnvironment();
      final ALEValidator validator = new ALEValidator(_queryEnvironment_1);
      validator.validate(parsedSemantics);
      final List<IValidationMessage> msgs = validator.getMessages();
      final Consumer<IValidationMessage> _function_2 = (IValidationMessage msg) -> {
        try {
          final IMarker marker = aleFile.createMarker(AleValidator.ALE_MARKER);
          marker.setAttribute(IMarker.MESSAGE, msg.getMessage());
          marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);
          marker.setAttribute(IMarker.CHAR_START, msg.getStartPosition());
          marker.setAttribute(IMarker.CHAR_END, msg.getEndPosition());
        } catch (Throwable _e) {
          throw Exceptions.sneakyThrow(_e);
        }
      };
      msgs.forEach(_function_2);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public static void resolveUris(final Dsl dsl) {
    final ArrayList<String> newSemantics = new ArrayList<String>();
    final IWorkspace ws = ResourcesPlugin.getWorkspace();
    final Consumer<String> _function = (String elem) -> {
      final URI uri = URI.createURI(elem);
      if (((!Objects.equal(ws, null)) && uri.isPlatform())) {
        final IResource file = ws.getRoot().findMember(uri.toPlatformString(true));
        final String path = file.getLocationURI().getRawPath();
        newSemantics.add(path);
      } else {
        newSemantics.add(elem);
      }
    };
    dsl.getAllSemantics().forEach(_function);
    dsl.getAllSemantics().clear();
    dsl.getAllSemantics().addAll(newSemantics);
  }
  
  private void cleanUpMarkers(final IFile file) {
    try {
      file.deleteMarkers(AleValidator.ALE_MARKER, true, IResource.DEPTH_ZERO);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
