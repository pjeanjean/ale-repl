/**
 * generated by Xtext 2.10.0
 */
package org.eclipse.emf.ecoretools.ui.contentassist;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import org.eclipse.acceleo.query.ast.Expression;
import org.eclipse.acceleo.query.runtime.ICompletionProposal;
import org.eclipse.acceleo.query.runtime.ICompletionResult;
import org.eclipse.acceleo.query.runtime.IQueryEnvironment;
import org.eclipse.acceleo.query.runtime.impl.BasicFilter;
import org.eclipse.acceleo.query.runtime.impl.QueryCompletionEngine;
import org.eclipse.acceleo.query.validation.type.IType;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.runtime.IPath;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl;
import org.eclipse.emf.ecoretools.ale.ALEInterpreter;
import org.eclipse.emf.ecoretools.ale.core.parser.DslBuilder;
import org.eclipse.emf.ecoretools.ale.core.parser.visitor.ParseResult;
import org.eclipse.emf.ecoretools.ale.core.validation.ALEValidator;
import org.eclipse.emf.ecoretools.ale.implementation.Block;
import org.eclipse.emf.ecoretools.ale.implementation.ModelUnit;
import org.eclipse.emf.ecoretools.ui.contentassist.AbstractAleProposalProvider;
import org.eclipse.emf.workspace.util.WorkspaceSynchronizer;
import org.eclipse.jface.viewers.StyledString;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.nodemodel.impl.AbstractNode;
import org.eclipse.xtext.nodemodel.impl.CompositeNode;
import org.eclipse.xtext.nodemodel.impl.CompositeNodeWithSemanticElement;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext;
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor;
import org.eclipse.xtext.ui.editor.model.IXtextDocument;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

@SuppressWarnings("all")
public class AleProposalProvider extends AbstractAleProposalProvider {
  @Override
  public void completeExpression_Feature(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final String candidate = this.getOffsetPrefix(context);
    this.addProposals(candidate, model, context, acceptor);
  }
  
  @Override
  public void completeExpression_Name(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final String candidate = this.getOffsetPrefix(context);
    this.addProposals(candidate, model, context, acceptor);
  }
  
  @Override
  public void complete_expression(final EObject model, final RuleCall ruleCall, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    final String candidate = this.getOffsetPrefix(context);
    this.addProposals(candidate, model, context, acceptor);
  }
  
  private void addProposals(final String expression, final EObject model, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    boolean _isEmpty = expression.isEmpty();
    if (_isEmpty) {
      return;
    }
    final IFile aleFile = WorkspaceSynchronizer.getFile(model.eResource());
    final IPath dslPath = aleFile.getFullPath().removeFileExtension().addFileExtension("ecore");
    final ResourceSetImpl rs = new ResourceSetImpl();
    Map<String, Object> _extensionToFactoryMap = rs.getResourceFactoryRegistry().getExtensionToFactoryMap();
    XMIResourceFactoryImpl _xMIResourceFactoryImpl = new XMIResourceFactoryImpl();
    _extensionToFactoryMap.put("*", _xMIResourceFactoryImpl);
    final List<EPackage> ecorePkgs = DslBuilder.load(dslPath.toString(), rs);
    byte[] _bytes = context.getDocument().get().getBytes(StandardCharsets.UTF_8);
    final ByteArrayInputStream stream = new ByteArrayInputStream(_bytes);
    final ALEInterpreter interpreter = new ALEInterpreter();
    IQueryEnvironment _queryEnvironment = interpreter.getQueryEnvironment();
    final List<ParseResult<ModelUnit>> parsedSemantics = new DslBuilder(_queryEnvironment).parse(ecorePkgs, Arrays.<InputStream>asList(stream));
    final Function1<ParseResult<ModelUnit>, ModelUnit> _function = (ParseResult<ModelUnit> it) -> {
      return it.getRoot();
    };
    final Function1<ModelUnit, EList<String>> _function_1 = (ModelUnit it) -> {
      return it.getServices();
    };
    final List<String> services = IterableExtensions.<String>toList(Iterables.<String>concat(IterableExtensions.<ModelUnit, EList<String>>map(IterableExtensions.<ModelUnit>filterNull(ListExtensions.<ParseResult<ModelUnit>, ModelUnit>map(parsedSemantics, _function)), _function_1)));
    interpreter.registerServices(services);
    Map<String, Set<IType>> variableTypes = CollectionLiterals.<String, Set<IType>>newHashMap();
    int _offset = context.getOffset();
    int _minus = (_offset - 1);
    final Expression contextExp = this.getExpression(parsedSemantics, _minus);
    IQueryEnvironment _queryEnvironment_1 = interpreter.getQueryEnvironment();
    final ALEValidator validator = new ALEValidator(_queryEnvironment_1);
    if ((contextExp != null)) {
      variableTypes = validator.getValidationContext(contextExp, parsedSemantics);
    }
    boolean _isEmpty_1 = variableTypes.entrySet().isEmpty();
    if (_isEmpty_1) {
      final Block block = this.getBlock(parsedSemantics, context.getOffset());
      variableTypes = validator.getValidationContext(block, parsedSemantics);
    }
    IQueryEnvironment _queryEnvironment_2 = interpreter.getQueryEnvironment();
    final QueryCompletionEngine engine = new QueryCompletionEngine(_queryEnvironment_2);
    final ICompletionResult completionResult = engine.getCompletion(expression, expression.length(), variableTypes);
    BasicFilter _basicFilter = new BasicFilter(completionResult);
    final List<ICompletionProposal> proposals = completionResult.getProposals(_basicFilter);
    final Consumer<ICompletionProposal> _function_2 = (ICompletionProposal proposal) -> {
      String _proposal = proposal.getProposal();
      final StyledString styledText = new StyledString(_proposal);
      styledText.setStyle(0, proposal.getProposal().length(), StyledString.QUALIFIER_STYLER);
      String _proposal_1 = proposal.getProposal();
      int _defaultPriority = this.getPriorityHelper().getDefaultPriority();
      int _plus = (_defaultPriority + 1);
      acceptor.accept(this.doCreateProposal(_proposal_1, styledText, null, _plus, context));
    };
    proposals.forEach(_function_2);
  }
  
  /**
   * Return the top containing Expression
   */
  private org.eclipse.emf.ecoretools.ale.Expression rootExpression(final EObject element) {
    org.eclipse.emf.ecoretools.ale.Expression res = null;
    EObject current = element;
    while ((current != null)) {
      {
        if ((current instanceof org.eclipse.emf.ecoretools.ale.Expression)) {
          res = ((org.eclipse.emf.ecoretools.ale.Expression)current);
        }
        current = current.eContainer();
      }
    }
    return res;
  }
  
  /**
   * Search in the AST for an ALE Expression at the given offset.
   * 
   * Return null if not found
   */
  private Expression getExpression(final List<ParseResult<ModelUnit>> parsedSemantics, final int offset) {
    Expression res = null;
    int start = 0;
    int end = 0;
    boolean _isEmpty = parsedSemantics.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      final ParseResult<ModelUnit> unit = IterableExtensions.<ParseResult<ModelUnit>>head(parsedSemantics);
      final Iterable<Expression> allExps = Iterables.<Expression>filter(unit.getStartPositions().keySet(), Expression.class);
      final Function1<Expression, Boolean> _function = (Expression exp) -> {
        return Boolean.valueOf((((unit.getStartPositions().get(exp)).intValue() <= offset) && ((unit.getEndPositions().get(exp)).intValue() >= offset)));
      };
      final Expression candidate = IterableExtensions.<Expression>findFirst(allExps, _function);
      if ((candidate != null)) {
        res = candidate;
        start = (unit.getStartPositions().get(candidate)).intValue();
        end = (unit.getEndPositions().get(candidate)).intValue();
        while ((res.eContainer() instanceof Expression)) {
          EObject _eContainer = res.eContainer();
          res = ((Expression) _eContainer);
        }
      }
    }
    return res;
  }
  
  /**
   * Search in the AST for an ALE Block at the given offset.
   * 
   * Return null if not found
   */
  private Block getBlock(final List<ParseResult<ModelUnit>> parsedSemantics, final int offset) {
    Block res = null;
    int start = 0;
    int end = 0;
    boolean _isEmpty = parsedSemantics.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      final ParseResult<ModelUnit> unit = IterableExtensions.<ParseResult<ModelUnit>>head(parsedSemantics);
      final Iterable<Block> allExps = Iterables.<Block>filter(unit.getStartPositions().keySet(), Block.class);
      final Function1<Block, Boolean> _function = (Block block) -> {
        return Boolean.valueOf((((unit.getStartPositions().get(block)).intValue() <= offset) && ((unit.getEndPositions().get(block)).intValue() >= offset)));
      };
      final Block candidate = IterableExtensions.<Block>findFirst(allExps, _function);
      if ((candidate != null)) {
        res = candidate;
        start = (unit.getStartPositions().get(candidate)).intValue();
        end = (unit.getEndPositions().get(candidate)).intValue();
        Iterable<Block> _drop = IterableExtensions.<Block>drop(allExps, 1);
        for (final Block block : _drop) {
          {
            boolean _and = false;
            Integer _get = unit.getStartPositions().get(block);
            boolean _lessEqualsThan = (start <= (_get).intValue());
            if (!_lessEqualsThan) {
              _and = false;
            } else {
              Integer _get_1 = unit.getEndPositions().get(block);
              boolean _lessEqualsThan_1 = ((_get_1).intValue() <= end);
              _and = _lessEqualsThan_1;
            }
            start = (unit.getStartPositions().get(block)).intValue();
            end = (unit.getEndPositions().get(block)).intValue();
          }
        }
      }
    }
    return res;
  }
  
  /**
   * Find the Block node containing this node
   * 
   * Return null if not found
   */
  private CompositeNode getBlockNode(final INode node) {
    final String debugDump = NodeModelUtils.compactDump(node.getRootNode(), true);
    INode current = node;
    while ((!Objects.equal(current, null))) {
      {
        if ((current instanceof CompositeNodeWithSemanticElement)) {
          EObject _semanticElement = ((CompositeNodeWithSemanticElement)current).getSemanticElement();
          if ((_semanticElement instanceof org.eclipse.emf.ecoretools.ale.Block)) {
            return ((CompositeNode)current);
          }
        }
        current = current.getParent();
      }
    }
    return null;
  }
  
  /**
   * Find the Statement node at the offset
   * 
   * Return null if not found
   */
  private AbstractNode findStatementNode(final INode node, final int offset) {
    final CompositeNode block = this.getBlockNode(node);
    boolean _notEquals = (!Objects.equal(block, null));
    if (_notEquals) {
      final Function1<AbstractNode, Boolean> _function = (AbstractNode child) -> {
        return Boolean.valueOf(child.getTextRegion().contains(offset));
      };
      final AbstractNode candidate = IterableExtensions.<AbstractNode>findFirst(block.basicGetChildren(), _function);
      return candidate;
    }
    return null;
  }
  
  /**
   * Assuming {@link text} is a statement, try to find the start of the expression around the offset
   */
  private int findStart(final String text, final int offset) {
    int i = offset;
    while ((i > 0)) {
      {
        final String frame = text.substring((i - 1), (i + 1));
        if ((((Objects.equal(frame, ":=") || Objects.equal(frame, "+=")) || Objects.equal(frame, "-=")) || Objects.equal(frame, "in"))) {
          if ((i == offset)) {
            return offset;
          } else {
            return (i + 1);
          }
        }
        i--;
      }
    }
    final int whileIndex = text.indexOf("while");
    if ((whileIndex != (-1))) {
      final int openIndex = text.indexOf("(", whileIndex);
      if ((openIndex != (-1))) {
        return openIndex;
      }
    }
    final int ifIndex = text.indexOf("if");
    if ((ifIndex != (-1))) {
      final int openIndex_1 = text.indexOf("(", ifIndex);
      final int thenIndex = text.indexOf("then", ifIndex);
      if (((openIndex_1 != (-1)) && ((thenIndex == (-1)) || (openIndex_1 < thenIndex)))) {
        return openIndex_1;
      }
    }
    return 0;
  }
  
  /**
   * Return the beginning of the expression before the offset
   */
  private String getOffsetPrefix(final ContentAssistContext context) {
    try {
      INode _currentNode = context.getCurrentNode();
      int _offset = context.getOffset();
      int _minus = (_offset - 1);
      final AbstractNode stmtNode = this.findStatementNode(_currentNode, _minus);
      if ((stmtNode != null)) {
        final String stmtText = context.getDocument().get(stmtNode.getOffset(), stmtNode.getLength());
        int _offset_1 = context.getOffset();
        int _minus_1 = (_offset_1 - 1);
        int _offset_2 = stmtNode.getOffset();
        int _minus_2 = (_minus_1 - _offset_2);
        final int startIndex = this.findStart(stmtText, _minus_2);
        int _offset_3 = stmtNode.getOffset();
        final int startOffset = (_offset_3 + startIndex);
        IXtextDocument _document = context.getDocument();
        int _offset_4 = context.getOffset();
        int _minus_3 = (_offset_4 - startOffset);
        return _document.get(startOffset, _minus_3);
      }
      return "";
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
